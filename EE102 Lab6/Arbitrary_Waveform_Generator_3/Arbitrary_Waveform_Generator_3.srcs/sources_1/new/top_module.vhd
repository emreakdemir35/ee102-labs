library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity clock_main is
    Port (
        clk_in  : in  std_logic;  -- input clock (e.g., from FPGA pin)
        reset   : in  std_logic;
        dout_o  : out std_logic   -- Output clock signal
    );
end clock_main;

architecture Behavioral of clock_main is

    -- Component Declaration for the clocking wizard IP
    component clk_wiz_0  -- IP generated by Vivado Clocking Wizard
        port (
            clk_in1  : in  std_logic;  -- Input clock
            clk_out1 : out std_logic;  -- Output clock
            reset    : in  std_logic;  -- Reset signal
            locked   : out std_logic   -- Locked signal indicating the clock is stable
        );
    end component;

    -- Signals for internal clock outputs and the locked signal
    signal clk_out_1  : std_logic;
    signal clk_locked : std_logic;
begin
    -- Instantiating the clocking wizard IP
    clk_wiz_inst : clk_wiz_0
        port map (
            clk_in1  => clk_in,     -- Connect the input clock to the clk_in1 of the clocking wizard
            clk_out1 => clk_out_1,  -- Connect the generated clock output to internal signal
            reset    => reset,      -- Connect the reset signal
            locked   => clk_locked  -- Connect the locked signal (indicating if the clock is stable)
        );

    -- Process to handle the output signal based on the input clock and reset
    process(clk_out_1)
    variable operation : unsigned(12 downto 0) := (others => '0');
    variable sel: unsigned(2 downto 0) := (others => '0');
    variable limit: unsigned(7 downto 0) := (others => '0');
    begin
        if rising_edge(clk_out_1) then
            if reset = '1' or clk_locked = '0' then
                dout_o <= '0';  -- Hold the output low if reset is high or clock is not locked
                operation := (others => '0');
                report "Operation reset to 0";
            else
                sel := sel + 1;
                -- sel logic to increment limit values
                case sel is
                    when "000" =>
                        limit := to_unsigned(5, 8);
                        sel := sel + 1;
                    when "001" =>
                        limit := to_unsigned(5, 8);
                        sel := sel + 1;
                    when "010" =>
                        limit := to_unsigned(5, 8);
                        sel := sel + 1;
                    when "011" =>
                        limit := to_unsigned(5, 8);
                        sel := sel + 1;
                    when others =>
                        sel := (others => '0');
                end case;

                -- Operation logic
                if (to_integer(operation) < to_integer(limit)) then
                    operation := operation + 1;
                    dout_o <= '1';  -- Otherwise, pass the clock output to the dout_o signal
                    report "Operation incremented: " & integer'image(to_integer(operation));
                else
                    if (to_integer(limit) <= to_integer(operation) and to_integer(operation) < 2*(to_integer(limit))) then
                        operation := operation + 1;
                        dout_o <= '0';
                        report "Operation in the range limit to 2*limit: " & integer'image(to_integer(operation));
                    else
                        operation := (others => '0');
                        report "Operation reset to 0 after exceeding 2*limit: " & integer'image(to_integer(operation));
                    end if;
                end if;
            end if;
        end if;
    end process;

end Behavioral;
